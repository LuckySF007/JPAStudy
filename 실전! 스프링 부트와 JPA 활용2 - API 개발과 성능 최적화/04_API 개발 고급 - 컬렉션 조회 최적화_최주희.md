# 04.API 개발 고급 - 컬렉션 조회 최적화

## 컬렉션 패치 조인

- 컬렉션 패치 조인 시에 페이징은 불가능함
    - 일대다라서 데이터가 예측할 수 없이 조인하면서 증가되기때문
    - 일을 기준으로 페이징하는 것이 목적, 그러나 다를 기준으로 row가 생성됨
- 컬렉션 패치 조인은 1개만 가능

<br>

## 컬렉션 패치 조인 페이징 한계 돌파

- ToOne 관계를 모두 패치 조인하기
- 컬렉션은 지연로딩으로 조회
- 지연로딩 성능 최적화를 위해 `hibernate.default_batch_fetch_size` (글로벌 설정), `@BatchSize` (개별 설정)를 적용 → 이 옵션은 컬렉션이나 프록시 객체를 한꺼번에 설정한 사이즈만큼 IN 쿼리로 조회
    - 쿼리 호출 수가 1 + N 가 1 + 1 로 최적화됨
    - 조인보다 최적화됨 (이 방법은 각각 조회하므로 중복 데이터가 없음)
    - 페이징이 가능
    

<br>

## DTO 직접 조회

- jpa에서 dto를 직접 조회
- 컬렉션 조회 최적화 - 일대다 관계인 컬렉션은 in절을 활용하여 메모리에 미리 조회해서 최적화
- 플랫 데이터 최적화 - join 결과를 그대로 조회 후 애플리케이션에서 원하는 모양으로 직접 변환

<br>

## ⚠️ 권장 순서

1) 엔티티 조회 방식으로 우선 접근 후 DTO로 변환

1) 패치 조인으로 쿼리수를 최적화

2) 컬렉션 최적화

1) 페이징 필요 : `hibernate.default_batch_fetch_size` , `@BatchSize` 로 최적화

2) 페이징 불필요 : 패치 조인 사용

2) 엔티티 조회 방식으로 해결이 안되면 dto 조회 방식 사용 → 성능 최적화할 때 많은 코드를 변경해야함

3) dto 조회 방식으로 해결이 안되면 네이티브 sql / 스프링 jdbcTemplate

<br>

## OSIV

- Open EntityManger In View → 관례상 OSIV라함
- `spring.jpa.open-in-view: true`
- OSIV 전략 : 트랜잭션 시작처럼 최초 데이터베이스 커넥션 시작시점부터 API응답이 끝날떄까지 영속성 컨텍스트와 데이터베이스 커넥션을 유지하는 것을 말함 → view나 api 컨트롤러에서 지연로딩이 가능하게함
- 장점 : 영속성 컨텍스트와 db 커넥션을 유지함으로써 지연 로딩 사용 가능
- 단점 : 너무 오랜시간동안 커넥션 리소스를 사용하기 때문에 실시간 트래픽이 중요한 곳에서는 커넥션이 모자랄 수 있음 → 장애로 이어짐
- OSIV를 끄면 트랜잭션안에서 모든 지연로딩을 처리해야함 → 트랜잭션이 끝나기 전에 지연로딩을 강제로 호출해두어야하는 치명적 단점

<br>

## 커멘드와 쿼리 분리

- 실무에서 OSIV를 끈 상태로 복잡성을 관리하는 좋은 방법
- 비즈니스 로직은 성능에 크게 문제가 되지 않으나 복잡한 화면을 출력하기 위한 쿼리는 화면에 맞추어 성능을 최적화해야함 → 복잡하고 큰 애플리케이션을 개발한다면 명확한 분리 필요
- OrderService
    - OrderService : 핵심 비즈니스 로직
    - OrderQueryService : 화면이나 api에 마춘 서비스(주로 읽기 전용 트랜잭션 사용)