# 다양한 연관관계 매핑

## 다대일 [N:1]

### 연관관계 매핑시 고려사항 3가지

- 다중성
    - 다대일 : @ManyToOne
    - 일대다 : @OneToMany
    - 일대일 : @OneToOne
    - 다대다 : @ManyToMany → 실무에서 사용 금지
- 단방향, 양방향
    - 테이블
        - 외래 키 하나로 양쪽 조인 가능
        - 사실 방향이라는 개념 x
    - 객체
        - 참조용 필드가 있는 쪽으로만 참조 가능
        - 한쪽만 참조하면 단방향
        - 양쪽이 서로 참조하면 양방향 → 사실 단방향이 2개가 있는 것.
- 연관관계의 주인
    - 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음
    - 객체 양방향 관계는 A → B, B → A 처럼 참조가 2군데
    - 객체 양방향 관계는 참조가 2군데 있음. 둘 중 테이블의 외래 키를 관리할 곳을 지정해야 함.
    - 연관관계의 주인 : 외래 키를 관리하는 참조
    - 주인의 반대편 : 외래 키에 영향을 주지 않음, 단순 조회만

### 다대일 [N:1] - JPA에서 제일 많이 사용

- 단방향
    - 다(N, Many) 쪽으로 외래키가 가야한다.
    
    ```java
    @ManyToOne
    @JoinColumn(name = "~")
    ```
    
- 양방향
    - 반대쪽에 객체에서 추가해줘야한다. but 영향을 주지는 않음.
    
    ```java
    @OneToMany(mappedBy = "~")
    // 주인쪽 외래키 변수가 mappedBy에 들어간다.
    ```
    

## 일대다[1:N]

### 일대다 단방향(권장하지 않음)

- 1을 중심으로 관리
- DB에서는 다쪽에만 외래키가 가능

```java
@OneToMany
@JoinColumn(name = "~")
```

- JPA를 잘 모르는 사람은 동작을 구분하지 못해 이해를 못하고, 실무에서는 테이블이 수십개가 엮여 돌아가는데 운영이 힘들어진다.

### 일대다 단방향 정리

- 일이 연관관계의 주인
- 테이블은 다쪽에 외래키 존재
- 결국 특이한 구조 발생
- @JoinColumn 꼭! → 안 쓰면 조인 테이블 방식을 사용.

### 일대다 양방향

- 억지스럽게 된다.
- 공식적으로 존재X
- @JoinColumn(insertable=false, updatable=false)
- 읽기 전용 필드를 사용해 양방향 처럼 사용
- **다대일 양방향을 사용하자**

## 일대일[1:1]

### 일대일 관계

- 일대일 관계는 반대도 일대일
- 주테이블 or 대상 테이블 중 외래 키 선택 가능
    - 주 테이블
    - 대상 테이블
- 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가
- 하나밖에 가질 수 없다는 비즈니스 룰 필요.
- 다대일(@ManyToOne) 단방향 매핑과 유사
- 일대일 : 주테이블에 외래 키 양방향

```java
@OneToOne
@JoinColumn(name = "~")
```

```java
@OneToOne
@MappedBy(name = "~")
//읽기 전용이 된다.
```

- 단방향
    - 대상 테이블에 외래키를 주테이블에서 연관관계 매핑은 불가능하고 지원하지 않는다.
- 양방향
    - 양방향에서는 가능하지만 결국 일대일 주테이블에 외래키 양방향과 매핑 방법은 같음 → 뒤집으면 똑같기 때문이다.
- 비즈니스의 변경 → DBA 입장과 개발자의 입장이 다르다.

### 일대일 정리

- 주 테이블에 외래 키
    - 주 객체가 대상 객체의 참조를 가지는것 처럼 주테이블에 외래 키를 두고 대상 테이블을 찾음
    - 객체지향 개발자 선호
    - JPA매핑 편리
    - 장 : 주 테이블만 조회해도 데이터 존재 확인 가능
    - 단 : 값이 없으면 외래 키에 null 허용
- 대상 테이블에 외래키
    - 대상 테이블에 외래키가 존재
    - 전통적인 DBA 선호
    - 장 : 주테이블과 대상 테이블 일대일 → 일대다 관계 변경시 구조 유지
    - 단 : 프록시 기능의 한계로 지연로딩으로 설정해도 항상 즉시 로딩됨(추후 추가 설명)

## 다대다[N:M](복습 필요)

### 다대다 - 실무에서 사용 X

- 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음.
- 연결 테이블을 추가해서 일대다,다대일 관계로 풀어내야함.
- 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능(DB와 다른점)
- 단방향, 양방향 가능

```java
@ManyToMany
@JoinColumn(name = "~")
```

```java
@ManyToMany
@JoinTable(name = "~")
```

### 다대다 매핑의 한계

- 편리해 보이지만 실무에서 사용 X
- 연결 테이블이 단순히 연결만 하고 끝나지 않음
- 주문시간, 수량 같은 데이터가 들어올 수 있음.

### 다대다 한계 극복

- 연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격)
- @ManyToMany → @OneToMany, @ManyToOne

## 실전 예제 - 3. 다양한 연관관계 매핑

```java
@ManyToMany
@JoinTable(name = "CATEGORY_ITEM",
					joinColumns = @JoinColumn(name = "CATEGORY_ID"),
					inversJoinColumns = @JoinColumn(name = "ITEM_ID")
)
```

### N:M 관계는 1:N, N:1로

- 테이블의 N:M관계는 중간 테이블을 이용해서 1:N, N:1
- 실전에서는 중간 테이블이 단순하지 않다.
- @ManyToMany 는 제약 : 필드 추가 X, 엔티티 테이블 불일치
- 실전에서는 @ManyToMany 사용 X

### @JoinColumn

- 외래 키를 매핑할 때 사용
- 속성
    - name : 매핑할 외래 키 이름
    - referencedColumnName : 외래 키가 참조하는 대상 테이블의 컬럼명
    - foreignKey(DDL) : 외래 키 제약조건을 직접 지정할 수 있다. 이 속성은 테이블을 생성할 때만 사용한다.
    - unique, nullable insertable, updatable, columnDefinition, table : @Column의 속성과 같다.

### @ManyToOne

- 다대일 관계 매핑
- 속성
    - optional : false로 설정하면 연관된 엔티티가 항상 있어야 한다.
    - fetch : 글로벌 페치 전략을 설정한다.
    - cascade : 영속성 전이 기능을 사용한다.
    - targetEntity : 연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거의 사용하지 않는다. 컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있다.

### @OneToMany

- 다대일 관계 매핑
- 속성 : ManyToOne과 일치
    - mappedBy
    - fetch
    - cascade
    - targetEntity