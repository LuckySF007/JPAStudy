# JPA 기본 8

## 프록시

### em.find()와 em.getReference()의 차이

- `em.find()` : 데이터베이스를 통해서 실제 엔티티 객체를 조회한다.
- `em.getReference()` : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체를 조회한다.
  - 호출 시점이 아닌, 실제 사용 시점에 쿼리를 날린다.

### 프록시 동작원리

- 실제 클래스를 상속 받아서 만들어진다.
  - 실제 클래스와 겉모양이 같다.
- 사용하는 입장에서는 진짜 객체인지, 프록시 객체인지 구분해 사용할 필요가 없다.
- 프록시 객체는 실제 객체의 참조(target)를 보관한다.
- 프록시 객체의 메서드 호출 시 프록시 객체는 실제 객체의 메서드를 호출한다. (위임(delegate))

### 프록시 객체 초기화

~~~java
Member member = em.getReference(Member.class, "id01");
member.getName();
~~~

- `member.getName()`을 호출하면 프록시 객체는 영속성 컨텍스트에 초기화를 요청하고, DB에서 member를 조회한다. 그럼 실제 객체가 생성되고, 프록시 객체에 있는 target 정보에 따라 실제 객체의 메서드가 호출된다.

### 프록시의 특징

- 프록시 객체는 처음 사용할 때 한 번만 초기화된다.
- 프록시 객체를 초기화할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 초기화되면 프록시 객체를 통해 실제 엔티티 객체에 접근 가능한 구조다.
- 프록시 객체는 원본 엔티티를 상속받는다. 따라서 타입 체크 시 주의해야한다. (instanceof 사용해야 함)
- 같은 트랜잭션 안에서 `==`으로 비교 시, 같은 데이터를 조회했으면 true를 보장해야 한다.
  - 영속성 컨텍스트에 찾는 엔티티가 이미 존재하면 em.getReference()를 호출해도 실제 엔티티를 반환한다.
  - 이미 영속성 컨텍스트에 프록시 객체가 존재하면 em.find()를 호출해도 프록시 엔티티를 반환한다.
- 준영속 상태에서 프록시를 초기화하면 문제가 발생한다.

### 프록시 확인

- 프록시 인스턴스 초기화 여부 확인

  ~~~java
  PersistenceUnitUtil.isLoaded(Object entity)
  ~~~

- 프록시 클래스 확인 방법

  ~~~java
  entity.getClass().getName()
  ~~~

- 프록시 강제 초기화

  ~~~java
  org.hibernate.Hibernate.initialize(entity)
  ~~~

  - JPA 표준은 강제 초기화 기능이 없다. 강제 호출을 한다.(member.getName())





## 즉시 로딩과 지연 로딩

### 지연 로딩 LAZY 사용해 프록시로 조회

- 지연로딩으로 세팅되어 있다면 em.find() 시 프록시 객체가 된다.
- 실제 객체를 사용하는 시점에 초기화된다.

### 즉시 로딩 EAGER 사용해 함께 조회

- em.find() 시 실제 객체가 바로 조회된다.

### 프록시와 즉시로딩 주의

- <u>**가급적 지연 로딩만 사용하자.**</u>
- 즉시 로딩을 적용하면 예상치 못한 SQL이 발생할 수 있다.
- 즉시 로딩은 JPQL에서 N+1 문제를 야기한다.
  - N+1 문제는 지연로딩을 사용하거나, JPQL에서 fetch join을 사용하여 해결 가능하다.
- @ManyToOne, @OneToOne은 기본이 즉시 로딩이다. LAZY로 설정하자.
- @OneToMany, @ManyToMany는 기본이 지연 로딩이다.



## 지연 로딩 활용

### 이론적

- Member와 Team이 자주 함께 사용된다면, 즉시 로딩!
- Member와 Order가 가끔 함께 사용된다면, 지연 로딩!

### 실무

- **<u>모든 연관관계에 지연 로딩을 사용하자!</u>**
- **<u>실무에서 즉시 로딩을 사용하지 말자!</u>**
  - 즉시 로딩은 상상하지 못한 쿼리가 나간다.
- JPQL fetch join 이나, 엔티티 그래프 기능을 사용하자!





## 영속성 전이 : CASCADE

### 영속성 전이란?

- 특정 엔티티를 영속 상태로 만들 때, 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 사용한다.
  - 예) 부모 엔티티 저장 시 자식 엔티티도 같이 저장하고 싶을 때

### 옵션

~~~java
@OneToMany(cascade = CascadeType.ALL)
~~~

- 부모 저장 시, 자식도 다 저장한다. 삭제 시 삭제도 함께한다.
- cascade가 없다면, 부모도 persist 하고, 자식들도 각각 persist 하여 INSERT 해야한다.

### 주의할 점

- 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없다.
- 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐이다.





## 고아 객체

### 고아 객체 삭제

- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제한다.
- 즉, 참조가 제거된 엔티티를 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능이다.

### 옵션

~~~java
@OneToMany(orphanRemoval = true)
~~~

### 주의할 점

- **참조하는 곳이 하나일 때 사용해야한다.**
- **특정 엔티티가 개인 소유할 때 사용해야한다.**
- `@OneToOne`, `@OneToMany`만 가능하다.
- 개념적으로 부모 제거 시 자식은 고아가 되고, 고아 객체 제거 기능이 활성화되어 있다면 부모 제거시 자식도 함께 제거된다.
  - 이는 CascadeType.REMOVE 처럼 동작하는 예이다.





## 영속성 전이 + 고아 객체, 생명주기

~~~
@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
~~~

- 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화하고 em.remove()로 제거한다.
- 두 옵션을 모두 활성화 시, 부모 엔티티를 통해 자식의 생명주기를 관리할 수 있다.
- ~~도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현할 때 유용하다.(추가 학습 필요)~~



