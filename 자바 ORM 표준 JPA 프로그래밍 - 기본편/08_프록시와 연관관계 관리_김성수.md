# 프록시와 연관관계 관리

### 프록시

- em.find() vs em.getReference()
- em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회
- em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회

### 프록시 특징 1

- 실제 클래스를 상속 받아서 만들어짐
- 실제 클래스와 겉 모양이 같다.
- 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨.(이론상)
- 프록시 객체는 실제 객체의 참조(target)을 보관
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출

### 프록시 객체의 초기화

1. Client가 프록시 객체 메소드 호출
2. 프록시 객체는 처음에 실제 객체에 대한 참조가 없으므로 영속성 컨텍스트에 초기화 요청
3. 영속성 컨텍스트는 DB조회
4. DB로 부터 값을 읽어와 실제 Entity 생성
5. 프록시 객체는 실제 객체의 참조를 알게 되었으므로 메소드 호출

### 프록시 특징 2

- 프록시 객체는 처음 사용할 떄 한번만 초기화
- 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화 되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
- 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크 시 주의 해야 함(== 비교 x, instance of  사용 해야 함) !!
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생

### 프록시 확인

- 프록시 인스턴스의 초기화 여부 확인 PersistenceUnitUtil.isLoaded(Object entity)
- 프록시 클래스 확인 방법 entity.getClass().getName() 출력
- 프록시 강제 초기화 org.hibernate.Hibernate.initialize(entity)
- 참고 : JPA 표준은 강제 초기화 없음

### 지연 로딩(Lazy)

- 지연 로딩을 사용해 프록시로 조회
- 실제 사용하는 시점에 초기화(DB 조회)
    
    ```java
    Team team = member.getTeam(); 
    team.getName(); // 실제 team을 사용하는 시점(메소드 호출)에 초기화(DB 조회)
    ```
    

### 즉시 로딩(EAGER)

### 프록시와 즉시로딩 주의

- 가급적 지연 로딩만 사용(특히 실무에서)
- 즉시 로딩을 적용하면 예상치 못한 SQL이 발생
- 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.
- @ManyToOne, @OneToOne은 기본이 즉시 로딩 → LAZY로 설정
- @OneToMany, @ManyToMany는 기본이 지연 로딩

### 모든 연관관계에 지연 로딩을 사용해라!

- JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라!

### 영속성 전이 : CASCADE

- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때
- 예) 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장.
- 주의 !
    - 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음
    - 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐
    - 연관 관계가 하나일 때만 사용해야함(1.단일 소유자 2.라이프 사이클이 거의 유사할 때)

### CASCADE 옵션

- ALL : 모두 적용
- PERSIST : 영속(저장할 때)

### 고아객체

- 고아 객체 제거 : 부모 엔티티와 연관 관계가 끊어진 자식 엔티티를 자동으로 삭제
- orphanRemoval = true
- 주의
    - 참조하는 곳이 하나일 때 사용 해야함
    - 특정 엔티티가 단일 소유자일 때 사용
    - @OneToOne, @OneToMany 만 사용가능
    - 개념적으로 부모를 제거하면 자식은 고아가 된다. 따라서 고아 객체 제거 기능을 활성화 하면, 부모를 제거할 때 자식도 함께 제거된다. 이것은 CascadeType.REMOVE처럼 동작한다.

### 영속성 전이 + 고아 객체, 생명주기

- CasCadeType.ALL + orphanRemoval = true
- 스스로 생명 주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove로 제거
- 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명 주기를 관리할 수 있음
- 도메인 주도 설계(DDD)의 Aggregate Root개념을 구현할 때 유용