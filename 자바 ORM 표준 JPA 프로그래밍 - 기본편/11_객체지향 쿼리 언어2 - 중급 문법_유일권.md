# 11. 객체지향 쿼리 언어2 - 중급 문법

## 경로 표현식

- .(점)을 찍어 객체 그래프를 탐색하는 것
- 상태 필드 : 단순히 값을 저장하기 위한 필드, 경로 탐색의 끝, 탐색 X
- 연관 필드 : 연관관계를 위한 필드 → 묵시적 내부조인 때문에 조심해서 사용
    - 단일 값 연관 필드 : @ManyToOne, @OneToOne, 대상이 엔티티, **묵시적 내부조인 발생**, 탐색 O
    - 컬렉션 값 연관 필드 : @OneToMany, @ManyToMany, 대상이 컬렉션, **묵시적 내부조인 발생**, 탐색 X
        - FROM절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색 가능

### 명시적 조인, 묵시적 조인

- 명시적 조인 : Join 키워드 직접 사용
    - Select m from Member m **join m.team t**
- 묵시적 조인 : 경로 표현식에 의해 묵시적으로 SQL 조인 발생(내부 조인만 가능)
    - Select **m.team** from Member m

### 실무 조언

- **가급적 묵시적 조인 대신에 명시적 조인 사용**
- 조인은 SQL 튜닝에 중요 포인트
- 묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려움

## 페치 조인(fetch join)

### 실무에서 매우 중요

회원을 조회하면서 연관된 팀도 함꼐 조회(SQL이 한번에)

SQL을 보면 회원 뿐 아니라 팀도 한번에 SELECT

### 컬렉션 페치 조인

- 일대다 관계, 컬렉션 페치 조인
- 일대다 관계에서는 데이터가 뻥튀기 될 우려가 있다.

### DISTINCT

- SQL의 DISTINCT는 중복된 결과를 제거 → 모든 값이 같아야 제거됨
- JPQL의 DISTINCT는 2가지 기능
    - SQL에 DISTINCT추가
    - 애플리캐이션에서 엔티티 중복 제거

### 일반 조인과의 차이

- JPQL은 결과를 반환할 때 연관관계 고려X
- 단지 SELECT 절에 지정한 엔티티만 조회
- 여기서는 팀 엔티티만 조회하고, 회원 엔티티는 조회 X
- 페치 조인을 사용할 때만 연관된 엔티티도 함께 **조회(즉시 로딩)**
- **페치 조인은 객체 그래프를 SQL 한번에 조회하는 개념**

### 특징과 한계

- 페치 조인 대상에는 별칭을 줄수 없다.
    - 하이버데이트는 가능하지만, 가급적 사용하지 말라
- 둘 **이상의 컬렉션은 페치 조인이 불가능**
- **컬렉션을 페치 조인하면 페이징 API를 사용 불가능**
    - 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
    - 하이버네이트는 경고 로그를 남기고 메모리에서 페이징(매우 위험)
        
        → 모든 데이터를 모두 들고와서 잘라냄
        
    - batch size나 Default batch size를 수정해서 해결 가능
- 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선 적용됨
- 연관된 엔티티들을 SQL 한 번으로 조회 → 성능 최적화
- 실무에서 글로벌 로딩 전략은 모두 지연로딩 → 최적화가 필요한 곳만 페치 조인

## 엔티티 직접 사용

- JPQL에서 엔티티를 직접 사용하면 SQL에서 해당 엔티티의 기본 키 값을 사용
- 엔티티를 파라미터로 전달해도, 식별자를 직접 전달해도 실행되는 SQL은 같다.

## Named 쿼리 - 어노테이션

- 미리 정의해서 이름을 부여해두고 사용하는 JPQL
- 정적 쿼리이며, 어노테이션, XML에 정의된다.
- 어플리케이션 로딩시점에 초기화 되므로 실행중 JPQL을 SQL로 변환하는데 드는 비용이 없다.
- 어플리케이션 로딩 시점에 쿼리 검증

## 벌크 연산

- 한번에 SQL의 값을 모두 변경하려면?
- JPA 변경 감지 기능으로 실행하려면 너무 많은 SQL이 실행되야함
    - N건이면 N건의 Update SQL 실행
- 주의사항 : 영속성 컨텍스트를 무시하고 DB에 직접 쿼리함
    - 벌크 연산 먼저 수행 후 영속성 컨텍스트 초기화