# 객체지향 쿼리 언어2 - 중급 문법

## 경로 표현식

### 경로 표현식

- .을 찍어 객체 그래프를 탐색하는 것
- 상태 필드(state) : 단순히 값을 저장하기 위한 필드
- 연관 필드(association) : 연관관계를 위한 필드
    - 단일 값 연관 필드 : @ManyToOne, @OneToOne, 대상이 엔티티
    - 컬렉션 값 연관 필드 :  @OneToMany, @ManyToMany, 대상이 컬렉션

### 특징

- 상태 필드(state field) : 경로 탐색의 끝, 탐색 X
- 단일 값 연관 경로 :**묵시적 내부 조인(inner join) 발생**, 탐색 O → 신경써서 써야 한다. 튜닝이 어려움. 정정 위험하다.
- 컬렉션 값 연과 경로 : 묵시적 내부조인 발생, 탐색 X, but FROM 절에서 명시적 조인을 통해 **별칭을 얻으면 별칭을 통해 탐색 가능 → 실무에서는 명시적 조인을 쓰자!**

### 명시적 조인, 묵시적 조인

- 명시적 조인 : join 키워드 직접 사용
- 묵시적 조인 : 경로 표현식에 의해 묵시적으로 SQL 조인 발생(내부 조인만 가능) → 조인이 일어나는 상황을 한눈에 파악하기 어려움

## 페치 조인 1 - 기본

### 페치 조인(fetch join)

- SQL 조인 종류가 아니다.
- JPQL에서 성능 최적화를 위해 제공
- 연관된 엔티티나 컬렉션을 SQL 한번에 함께 조회하는 기능
- join fetch 명령어 사용
- 지연 로딩 X → 선택적으로 즉시 로딩 사용 가능

### 엔티티 페치 조인

- 회원을 조회하면서 연관된 팀도 함께 조회
- JPQL : select m from Member m **join fetch** m.team
- SQL : SELECT M.*, T.* FROM MEMBER M INNER JOIN TEAM T ON M.TEAM_ID=T.ID → INNER JOIN 이기 떄문에 팀이 없는 멤버는 출력 X

### 컬렉션 페치 조인

- 일대다 관계, 컬렉션 페치 조인

### 페치 조인과 DISTINCT

- SQL의 DISTINCT는 중복된 결과를 제거하는 명령
- JPQL의 DISTINCT 2가지 기능 제공
    - SQL에 DISTINCT를 추가
    - 애플리케이션에서 엔티티 중복 제거
- SQL에 DISTINCT는 완벽하게 동일해야 중복제거
- JPA에서 추가로 중복 제거시도 → 같은 식별자를 가진 Team 엔티티 제거 → 결국 옵션 제공
- 1대 다는 개수가 늘어나기때문에 조심, DISTINCT 사용

### 페치 조인과 일반 조인의 차이

- 일반 조인 실행시 연관된 엔티티를 함께 조회하지 않음
- JPQL은 결과를 반환할 때 연관관계 고려 X
- 단지 SELECT 절에 지정한 엔티티만 조회할 뿐
- 페치 조인을 사용할 때만 연관된 엔티티도 함께 조회(즉시 로딩)
- 객체 그래프를 SQL 한번에 조회하는 개념

## 페치 조인 2 - 한계

### 페치 조인의 특징과 한계

- 한계
    - 페치 조인 대상에는 별칭을 줄 수 없다.
        - 하이버 네이트는 가능, but 가급적 사용 X
    - 둘 이상의 컬렉션은 페치 조인 할 수 없다. → 일대 다대 다, 데이터 예상치 못하게 늘어날수도
    - 컬렉션을 페치 조인하면 페이징 API 사용 불가(재확인 필요)
        - 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
        - 하이버네이트는 경고 로그를 남기고 메모리에서 페이징(매우 위험)
        - @batchsize, hibernate.default_batch_fetch_size
        - dto로 sql 작성
- 특징
    - 연관된 엔티티들을 SQL 한 번으로 조회 - 성능 최적화
    - 엔티티에 직접 적용한느 글로벌 로딩 전략보다 우선함
        - @OneToMany(fetch = FetchType.LAZY) // 글로벌 로딩 전략
    - 실무에서 글로벌 로딩 전략은 모두 지연 로딩
    - 최적화 필요한 곳은 페치 조인
- 정리
    - 모든 것을 페치 조인으로 해결할 수는 없다.
    - 객체 그래프를 유지할 때 사용하면 효과적
    - 여러 테이블을 조인해서 전혀 다른 결과를 내야 하면, 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적
    - **페치 조인 복습하기**

## 엔티티 직접 사용

### 엔티티 직접 사용 - 기본 키 값

- JPQL에서 엔티티를 직접 사용하면 SQL에서 해당 엔티티의 기본 키 값을 사용
- select count(m.id) from ~ == select count(m) ~ → 같은 쿼리문

### 엔티티 직접 사용 - 외래 키 값

- 외래 키도 결국 식별자로 처리 되기 때문에 같은 쿼리문 발생

## Named 쿼리

### Named 쿼리 - 정적 쿼리

- 미리 정의해서 이름을 부여해두고 사용하는 JPQL
- 정적 쿼리
- 어노테이션, XML에 정의
- 애플리케이션 로딩 시점에 초기화 후 재사용
- 애플리케이션 로딩 시점에 쿼리를 검증 → 어노테이션으로 미리 올려놓기 때문에 에러를 바로 체크 가능

### 환경에 따른 설정

- XML이 항상 우선권을 가진다.
- 애플리케이션 운영 환경에 따라 다른 XML을 배포할 수 있다.

## 벌크 연산

### 벌크 연산

- 쿼리 한 번으로 여러 테이블 로우 변경(엔티티)
- executeUpdate() 결과는 영향받은 엔티티 수
- UPDATE, DELETE 지원
- INSERT(insert into .. select, 하이버네이트에서 지원)

### 주의

- 벌크 연산은 영속성 컨텍스트 무시 데이터 베이스 직접
    - 벌크연산 먼저 실행
    - 벌크연산 수행 후 영속성 컨텍스트 초기화 → flush는 커밋을 하거나 쿼리를 날릴 때 자동 실행
- 벌크 연산은 영속성 컨텍스트와 연동해서 사용 불가능