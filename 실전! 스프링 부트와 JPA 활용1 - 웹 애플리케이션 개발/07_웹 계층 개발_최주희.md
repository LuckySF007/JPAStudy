# 07.웹 계층 개발

## @Valid

- 컨트롤러에서 @RequestBody를 통해 데이터를 바인딩할 때 파라미터에 사용
- 객체에 부여된 제약조건의 유효성을 검증해준다.
- 예를 들어, Member 객체에 어떤 필드에 @NotEmpty 가 붙어있다면, 이 필드가 유효한지를 검증해줌

<br>

## BindingResult

컨트롤러에서 매개변수를 빈에 바인딩할때 발생한 오류 정보를 받기 위해 선언하는 객체

<br>

## API를 만들때는 절대 엔티티를 외부로 반환하면 안됨

비즈니스 로직에 엔티티를 사용했다면 화면단에 전달하는 로직에는 꼭 따로 dto를 만들어서 사용해라.

<br>

## jpa의 변경감지

- 엔티티의 필드 데이터값을 바꾸기만하면 jpa가 알아서 변경감지를 하여 커밋시점에 update문을 날림(dirty-checking)
- 준영속 엔티티(jpa가 더이상 관리하지 않는 엔티티, 임의로 만들어낸 엔티티인데 기존 식별자를 가지고 있으면 준영속 엔티티로 볼 수 있음)를 수정하는 2가지 방법
    - 변경감지 기능 사용 :
    - 병합(merge) 사용
        - 준영속 엔티티의 식별자 값으로 영속 엔티티를 조회하고 영속 엔티티의 값을 준영속 엔티티의 값으로 모두 교체(병합)한다. → 변경감지 기능으로 update 됨
        - 주의 : 변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경이 가능하지만 병합을 사용하면 모든 속성이 변경되므로 병합시 값이 없으면 null로 업데이트 할 위험도 있음 → **그냥 항상 변경감지 써라**
    

<br>

## 식별자 넘기기

- 컨트롤러에서 화면단의 객체 값을 받아오는 것이 아닌, 식별자 값만 받아와서 서비스로 넘긴다음 서비스 계층에서 엔티티 조회를 하는것이 좋다. 그래야 영속성을 생성한 후에 작업을 할 수 있기 때문
- 트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티를 조회하고, 엔티티의 데이터를 직접 변경하는것 권장